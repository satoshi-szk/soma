# スペクトログラム生成システム改善計画

## 1. 現状の課題

### 1.1 CWT計算の性能問題
- **計算量**: O(N × S) - N=音声サンプル数、S=周波数スケール数
- **問題**: 長尺音声（例：1時間）では計算に非常に時間がかかる
- **現状の対策**: 30秒以上のファイルを拒否するダイアログ（既に削除済み）

### 1.2 ダウンサンプリングのナイキスト問題
現在の実装では、出力ピクセル数に基づいて音声をダウンサンプリングしている：

```python
target_samples = width * 32  # 例: 768 * 32 = 24,576
audio_segment = resample(audio_segment, target_samples)
working_sample_rate = int(target_samples / segment_duration)
```

**問題**: 1時間の音声の場合
- `working_sample_rate = 24,576 / 3600 ≈ 6.8 Hz`
- ナイキスト周波数 = 3.4 Hz
- 表示したい12kHzの周波数情報が完全に失われる

### 1.3 ユーザー体験の問題
- 短い音声でもCWT計算中は待ち時間が発生
- ズーム操作時のレスポンスが悪い

---

## 2. 解決策：プログレッシブローディング + STFT/CWT併用（GUIプレビュー専用）

重要:
- **STFT は GUI のスペクトログラムプレビュー専用**であり、スナップ処理（リッジ検出 / Partial 生成）には **絶対に使用しない**。
- スナップ処理は従来どおり **CWT による JIT 解析**のみで行う（`MouseUp` / 編集操作の確定タイミング）。

### 2.1 基本戦略

```
┌─────────────────────────────────────────────────────────┐
│                    リクエスト受信                         │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Phase 1: STFT計算（高速）                               │
│  - 常に実行（GUIプレビューのみ）                          │
│  - hop size で時間解像度を制御（出力widthに合わせる）      │
│  - 結果を即座に返す（低品質ベースライン）                  │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
              ┌────────────────────────┐
              │ 表示窓長 < 閾値（30秒）？│
              └────────────────────────┘
                    │           │
                   Yes          No
                    │           │
                    ▼           ▼
┌──────────────────────────┐   ┌──────────────────────┐
│ Phase 2: CWT計算          │   │ STFTのみで終了       │
│ - バックグラウンド実行     │   │ （長尺は高品質不要）  │
│ - 完了後、高品質版に差替え │   └──────────────────────┘
└──────────────────────────┘
```

ここでの「表示窓長」は `time_end - time_start`（overviewなら全長、viewportなら可視領域）を指す。

### 2.2 STFTとCWTの特性比較

| 特性 | STFT | CWT |
|------|------|-----|
| 計算速度 | 高速（FFTベース） | 低速（畳み込み） |
| 時間解像度制御 | 容易（hop size） | 困難（全サンプル計算） |
| 周波数解像度 | 固定（窓サイズ依存） | 可変（対数スケール） |
| 低周波数の解像度 | 低い | 高い |
| 用途 | 概要表示、長尺音声 | 詳細表示、短尺音声 |

### 2.3 対数周波数軸への変換

STFTは線形周波数軸を出力するため、CWTと同じ対数周波数軸に変換が必要：

```
STFT出力（線形）: [0Hz, 100Hz, 200Hz, 300Hz, ...]
       ↓ リサンプリング
CWT互換（対数）:  [20Hz, 40Hz, 80Hz, 160Hz, ...]
```

---

## 3. API/イベント設計（Fire & Forget + Push）

フロントエンドの役割を最小化するため、プレビュー生成のリクエストは **Fire & Forget** とする。
結果の返却タイミング（低品質/高品質、生成する/しない、キャンセル）は **常に Python 側が判断**し、フロントエンドは **イベントストリームを購読して反映するだけ**とする。

### 3.1 フロントからのリクエスト（例）

- `request_overview_preview(...)`（初期化時に1回）
- `request_viewport_preview(...)`（ズーム/パン完了後に1回）

どちらも「受付できたか」のみ返し、フロントはそのレスポンスを待ってUI更新しない（結果はイベントで届く）。

### 3.2 Python→Frontend のイベント（例）

プレビューの更新はイベントで通知する。

```json
{
  "type": "spectrogram_preview_updated",
  "kind": "overview" | "viewport",
  "quality": "low" | "high",
  "final": true | false,
  "preview": {
    "width": 768,
    "height": 320,
    "data": [0, 1, 2, "..."],
    "time_start": 0.0,
    "time_end": 10.0,
    "freq_min": 20.0,
    "freq_max": 12000.0
  }
}
```

要点:
- `quality="low"` は STFT、`quality="high"` は CWT を想定。
- `final=true` のとき、その `kind` について当面の更新は発生しない（フロントは追加の待ち処理不要）。
- 連続リクエスト時は Python 側で古い計算を破棄し、**最新の要求に対する結果だけ**を publish する（フロントの request_id 管理を不要にする）。

---

## 4. 実装タスク

### Phase 1: STFT基盤

#### 4.1 STFT計算関数の実装
```python
def _stft_magnitude(
    audio: np.ndarray,
    sample_rate: int,
    freq_min: float,
    freq_max: float,
    width: int,   # 出力の時間解像度
    height: int,  # 出力の周波数解像度
) -> np.ndarray:
    """
    STFTを計算し、対数周波数軸にリサンプリングして返す
    """
```

#### 4.2 対数周波数軸リサンプリング
- 線形周波数軸のSTFT結果を対数周波数軸に補間
- scipy.interpolate を使用

### Phase 2: CWT修正

#### 4.3 ナイキスト問題の修正
```python
# 修正前
target_samples = width * 32

# 修正後
min_sample_rate = max(2000.0, effective_freq_max * 2.2)
min_samples = int(min_sample_rate * segment_duration)
target_samples = max(width * 32, min_samples)
```

### Phase 3: 2段階更新（Push）

#### 4.4 バックエンド: 2段階処理（イベント publish）
```python
def start_viewport_preview_async(...):
    # 1. STFTで即座に低品質 preview を publish（quality='low'）
    # 2. 表示窓長が閾値以下なら CWT をバックグラウンドで開始
    # 3. CWT完了時に高品質 preview を publish（quality='high', final=True）
    # 4. 閾値超過なら low のみ publish して final=True
```

#### 4.5 フロントエンド: イベント購読のみ
- 初期化時/ズーム時にリクエストを投げる（fire & forget）
- `spectrogram_preview_updated` を購読して、届いた `preview` を描画に反映する

### Phase 4: 最適化（オプション）

#### 4.6 CWTのFFT法
```python
# 中程度の長さのデータで高速化の可能性
pywt.cwt(..., method='fft')
```

#### 4.7 リサンプル結果のキャッシュ
- 複数解像度の音声データを事前計算・保持
- メモリとのトレードオフ

---

## 5. 閾値の設計

| パラメータ | 値 | 理由 |
|-----------|-----|------|
| CWT実行閾値 | 30秒 | **ファイル長ではなく表示窓長**（`time_end - time_start`）で判定する |
| STFT窓サイズ | 2048〜4096 | 周波数解像度とのバランス |
| STFT hop size | 動的（width依存） | 出力ピクセル数に合わせる |

---

## 6. テスト計画

### 6.1 機能テスト
- 短尺音声（10秒）: STFT → CWT の2段階更新を確認
- 長尺音声（5分）: STFTのみで表示されることを確認
- ズーム操作: 各ズームレベルで正しく動作することを確認

### 6.2 性能テスト
- STFT計算時間: 1時間級の音声でも「待たされない」こと（目安: 数秒以内）
- CWT計算時間: 30秒の音声で5秒以内（目安）

### 6.3 品質テスト
- STFTとCWTの見た目の一貫性（対数周波数軸変換の精度）
- 切り替え時の違和感がないこと

---

## 7. 将来の拡張可能性

- **WebGPU/WebGL**: スペクトログラム描画の高速化
- **ストリーミング計算**: 超長尺音声の部分的読み込み
- **キャッシュ戦略**: 計算済みスペクトログラムのディスクキャッシュ
